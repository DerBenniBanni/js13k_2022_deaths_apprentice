const color = {
    cloakBg:'#110033',
    cloakOl:'#aa00ff',
    bone:'#eeffee',
    floorBg:'#110033',
    floorOl:'#9944ff66',
    brickBg:'#332255',
    brickOl:'#9944ff66',
    doorBg:'#772200',
    doorOl:'#aa5500',
    jumpBg:'#552233',
    jumpOl:'#ff77ff66',
}

const LOCALSTORAGE_KEY = 'DeathsApprenticeJS13k2022BestTime';


class Game {
    constructor(canvas, leveldata) {
        this.canvas = canvas;
        this.levels = [];
        this.levelPointer = -1;
        this.player = null;
        this.initLevels(leveldata);
        this.musicPlaying = false;

        this.ctx = canvas.getContext('2d');
        this.width = this.canvas.width;
        this.height = this.canvas.height;
        this.objs = [];
        this.keys = {
            'KeyA':'l',
            'KeyD':'r',
            'KeyW':'j',
            'ArrowLeft':'l',
            'ArrowRight':'r',
            'ArrowUp':'j',
            'ShiftLeft':'d',
            'ShiftRight':'d'
        };
        this.actions = {
            l:false,
            r:false,
            j:false
        };
        let game = this;
        document.addEventListener('keydown', (ev)=> game.keydown(ev));
        document.addEventListener('keyup', (ev)=> game.keyup(ev));
        this.lastUpdate = Date.now();
        this.startTime = null;
        this.speedRunTime = null;
    }
    initLevels(leveldata) {
        this.levels = leveldata.split('\n#\n');
        this.levelPointer = -1;
    }
    finishedCurrentLevel() {
        if(this.levelPointer == this.levels.length - 2) {
            // finished last level with hourglass, stop timer
            this.speedRunTime = (Date.now() - this.startTime) / 1000.0;
            let currentBest = localStorage.getItem(LOCALSTORAGE_KEY);
            if(!currentBest || currentBest > this.speedRunTime) {
                localStorage.setItem(LOCALSTORAGE_KEY, this.speedRunTime);
            }
        }
        if(this.levelPointer >= this.levels.length - 1) {
            return; // no more levels
        }
        this.player.stopUpdates = true;
        let game = this;
        this.addObj(new LevelBlender({
            target:this.player,
            game:game,
            finishedCallback:(blendObj)=>{
                game.loadNextLevel();
            }
        }));
    }
    loadNextLevel() {
        if(this.levelPointer >= this.levels.length - 1) {
            return; // no more levels
        }
        this.levelPointer++;
        this.loadCurrentLevel();
    }
    loadCurrentLevel() {
        this.objs = [];
        this.player = null;
        let leveldata = this.levels[this.levelPointer];
        leveldata.split("ยง").forEach(levelObject => {
            let data = levelObject.split("~");
            if(data.length < 2) {
                return;
            }
            let obj = {};
            if(data.length >= 3) {
                obj.pos = new Vec(data[1] * 1, data[2] * 1);
            }
            if(['f','d','j','s'].indexOf(data[0]) > -1) {
                obj.size = new Vec(data[3] * 1, data[4] * 1);
            }
            if(data[0] == "f") {
                game.addObj(new Floor(obj));
            } else if(data[0] == "s") {
                obj.directionUp = data[5] == "1";
                game.addObj(new Spikes(obj));
            } else if(data[0] == "d") {
                obj.lock = data[5];
                game.addObj(new Door(obj));
            } else if(data[0] == "k") {
                obj.unlocking = data[3];
                game.addObj(new Key(obj));
            } else if(data[0] == "j") {
                obj.jumpforce = (data[5] || 1.5) * 1;
                game.addObj(new Jumppad(obj));
            } else if(data[0] == "p") {
                game.player = game.addObj(new Player(obj));
            } else if(data[0] == "h") {
                obj.startTime = data[3] * 1;
                game.addObj(new Hourglass(obj));
            } else if(data[0] == "t") {
                obj.text = data[3];
                if(game.speedRunTime) {
                    obj.text = obj.text.replace("{speedRunTime}", this.getTimeFormated(game.speedRunTime));
                    localStorage.getItem(LOCALSTORAGE_KEY);
                    obj.text = obj.text.replace("{bestTime}", this.getTimeFormated(localStorage.getItem(LOCALSTORAGE_KEY)));
                }
                obj.startTime = data[4] * 1;
                obj.textsize = data[5];
                game.addObj(new Text(obj));
            }
        });
        this.player.stopUpdates = true;
        this.player.stopRendering = true;
        this.addObj(new LevelBlender({
            target:this.player,
            game:game,
            radius:1,
            rate:-game.canvas.width,
            finishedCallback:(blendObj)=>{
                game.removeObj(blendObj);
                game.player.respawn();
            }
        }));
    }
    keydown(ev) {
        if(this.keys[ev.code]) {
            this.actions[this.keys[ev.code]] = true;
        }
        if(ev.code == 'KeyM') {
            if(this.musicPlaying) {
                audio.pause();
                this.musicPlaying = false;
            } else {
                audio.play();
                this.musicPlaying = true;
            }
        }
        if(ev.code == 'KeyO') {
            this.loadNextLevel();
        }
        if(this.levelPointer == 0 && !this.startTime) {
            this.startTime = Date.now();
        }
    }
    keyup(ev) {
        if(this.keys[ev.code]) {
            this.actions[this.keys[ev.code]] = false;
            if(this.keys[ev.code] == "j" && this.player) {
                this.player.jumpReleased = true;
            }
        }
    }
    run() {
        this.lastUpdate = Date.now();
        this.requestFrame();
        audio.play();
        this.musicPlaying = true;
    }
    requestFrame() {
        requestAnimationFrame(() => {this.updateAndRender()});
    }
    updateAndRender() {
        let now = Date.now();
        let delta = (now - this.lastUpdate)/1000;
        this.lastUpdate = now;
        this.objs.forEach(o => o.update(delta));
        this.objs = this.objs.filter(o=>o.ttl > 0);
        this.ctx.fillStyle = '#00001188';
        this.ctx.fillRect(0, 0, this.width, this.height);
        this.objs.forEach(o => o.render(this.ctx));
        if(!this.speedRunTime) {
            let runTime = (now - (this.startTime ? this.startTime : now)) / 1000.0;
            let elapsedTime = this.getTimeFormated(runTime);
            this.ctx.textAlign = "center";
            this.ctx.font = "24px serif";
            this.ctx.fillStyle = '#ffffff';
            this.ctx.fillText(elapsedTime,750,24);
        }
        this.requestFrame();
    }
    getTimeFormated(runTime) {
        runTime = runTime || 0;
        let minutes = Math.floor(runTime / 60.0);
        let seconds = Math.floor(runTime - minutes * 60.0);
        let tenth = Math.floor((runTime - minutes * 60.0 - seconds) * 10);
        return ("0" + minutes).substr(-2) + ":" + ("0" + seconds).substr(-2) + "." + tenth;
    }
    getColliderObjs(collGroup) {
        return this.objs.filter(o=>o.collGroup == collGroup);
    }
    addObj(obj) {
        this.objs.push(obj);
        obj.game = this;
        return obj;
    }
    removeObj(objToRemove) {
        this.objs = this.objs.filter(o => o !== objToRemove);
    }
}
class Vec {
    constructor(x,y) {
        this.x = x;
        this.y = y;
    }
    clone() {
        return new Vec(this.x, this.y);
    }
    multi(multi) {
        return new Vec(this.x * multi, this.y * multi);
    }
    plus(other) {
        return new Vec(this.x + other.x, this.y + other.y);
    }
    add(x,y) {
        this.x += x || 0;
        this.y += y || 0;
        return this;
    }
}
class Obj {
    constructor({pos, size, origin, ttl}) {
        this.pos = pos || new Vec(0,0);
        this.size = size || new Vec(0,0);
        this.origin = origin || new Vec(0.5,0.5);;
        this.type = "obj";
        this.collGroup = "";
        this.fillColor = color.floorBg;
        this.strokeColor = color.floorOl;
        this.game = null;
        this.ttl = ttl || Infinity;
    }
    render(ctx) {
        this.renderStart(ctx);
        ctx.fillStyle = this.fillColor;
        ctx.strokeStyle = this.strokeColor;
        if(this.fillColor) {
            ctx.fillRect(-this.size.x * this.origin.x, -this.size.y * this.origin.y, this.size.x, this.size.y);
        }
        if(this.strokeColor) {
            ctx.beginPath();
            ctx.rect(-this.size.x * this.origin.x, -this.size.y * this.origin.y, this.size.x, this.size.y);
            ctx.stroke();
        }
        this.renderPostProcess(ctx);
        ctx.restore();
    }
    renderStart(ctx) {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
    }
    renderPostProcess(ctx) {}
    update(delta) {
        this.ttl -= delta;
    }
}
class Dust extends Obj {
    constructor(obj) {
        let ttl = obj.ttl || 0.5;
        let shrinkrate = obj.size / ttl;
        let dx = obj.dx || 80;
        let dy = obj.dy || 80;
        let dxd = obj.dxd || dx/2;
        let dyd = obj.dyd || dy/2;
        obj.size = new Vec(obj.size, obj.size);
        super(obj);
        this.dPos = new Vec(Math.random() * dx - dxd, Math.random() * dy - dyd);
        this.fillColor = "#aaaaaa";
        this.strokeColor = null;
        this.ttl = ttl;
        this.shrinkrate = shrinkrate;
    }
    update(delta) {
        super.update(delta);
        this.size.x -=  this.shrinkrate * delta;
        this.size.y -=  this.shrinkrate * delta;
        this.pos.add(this.dPos.x * delta, this.dPos.y * delta);
    }
}
class LevelBlender extends Obj {
    constructor({game, rate, radius, target, finishedCallback}) {
        super({});
        this.game = game;
        this.target = target || this.game.player;
        this.rate = rate || game.canvas.width / 2;
        this.radius = radius || game.canvas.width;
        this.finishedCallback = finishedCallback || null;
    }
    update(delta) {
        this.radius -= this.rate * delta;
        if(this.radius < 0.1) {
            this.radius = 0.1;
            if(this.finishedCallback) {
                this.finishedCallback(this);
            }
            this.ttl = -1;
        }
        if(this.radius > this.game.canvas.width) {
            this.radius = this.game.canvas.width;
            if(this.finishedCallback) {
                this.finishedCallback(this);
            }
            this.ttl = -1;
        }
    }
    render(ctx) {
        ctx.beginPath();
        ctx.fillStyle = "#000000";
        ctx.rect(this.game.canvas.width, 0, -this.game.canvas.width, this.game.canvas.height);
        ctx.arc(this.target.pos.x, this.target.pos.y, this.radius, 0, 2*Math.PI);
        ctx.fill();
    }

}
class Floor extends Obj {
    constructor(obj) {
        obj.origin = new Vec(0, 0);
        super(obj);
        this.type = "floor";
        this.collGroup = "level";
        this.fillColor = color.floorBg;
        this.strokeColor = color.floorOl;
        this.brickFillColor = color.brickBg;
        this.brickStrokeColor = color.brickOl;
        this.bricks = [];
        let x = 0;
        while(x < this.size.x) {
            let w = Math.ceil(Math.random() * 15) + 5;
            if(x + w > this.size.x) {
                w = this.size.x - x;
            }
            let h = Math.ceil(Math.random() * 5) + 3;
            let y = Math.floor(Math.random() * 2);
            this.bricks.push({
                x: x,
                y: y,
                w: w,
                h: h
            });
            x += w;
        }
        let y = 0;
        while(y < this.size.y) {
            let h = Math.ceil(Math.random() * 15) + 5;
            if(y + h > this.size.y) {
                h = this.size.y - y;
            }
            let w = Math.ceil(Math.random() * 5) + 3;
            let x = Math.floor(Math.random() * 2);
            this.bricks.push({
                x: x,
                y: y,
                w: w,
                h: h
            });
            y += h;
        }
        y = 0;
        while(y < this.size.y) {
            let h = Math.ceil(Math.random() * 15) + 5;
            if(y + h > this.size.y) {
                h = this.size.y - y;
            }
            let w = Math.ceil(Math.random() * 5) + 3;
            let x = Math.floor(Math.random() * 2);
            this.bricks.push({
                x: this.size.x - x - w,
                y: y,
                w: w,
                h: h
            });
            y += h;
        }
    }
    renderPostProcess(ctx) {
        this.bricks.forEach(b => {
            ctx.fillStyle = this.brickFillColor;
            ctx.strokeStyle = this.brickStrokeColor;
            ctx.fillRect(b.x , b.y, b.w, b.h);
            ctx.beginPath();
            ctx.rect(b.x , b.y, b.w, b.h);
            ctx.stroke();
        });
    }
}

class Spikes extends Obj {
    constructor(obj) {
        obj.origin = new Vec(0, 0);
        super(obj);
        this.directionUp = obj.directionUp !== false;
        this.type = "spikes";
        this.collGroup = "level";
        this.fillColor = "#aaaaaa";
        this.strokeColor = "#dddddd";
    }
    render(ctx) {
        this.renderStart(ctx);
        let y1 = this.size.y;
        let y2 = 0;
        if(this.directionUp) {
            y1 = 0;
            y2 = this.size.y;
        }
        ctx.strokeStyle = this.strokeColor;
        ctx.fillStyle = this.fillColor;
        ctx.beginPath();
        ctx.moveTo(0,y2);
        let steps = Math.ceil(this.size.x / 10);
        let stepsize = this.size.x / steps;
        for(let x = 0; x <= this.size.x - stepsize +0.1; x+=stepsize) {
            ctx.lineTo(x+stepsize/2,y1);
            ctx.lineTo(x+stepsize, y2);
        }
        ctx.fill();
        ctx.stroke();
        ctx.restore();
    }
}

class Door extends Obj {
    constructor(obj) {
        obj.origin = new Vec(0, 0);
        super(obj);
        this.type = "door";
        this.collGroup = "level";
        this.fillColor = color.doorBg;
        this.strokeColor = color.doorOl;
        this.lock = obj.lock || 'allLocks';
        this.unlocked = false;
    }
    update(delta) {
        if(this.unlocked && this.size.y > 0) {
            this.size.y -= delta * 40;
            this.pos.y += delta * 40;
        }
    }
}

class Jumppad extends Obj {
    constructor(obj) {
        obj.origin = new Vec(0, 0);
        super(obj);
        this.jumpforce = obj.jumpforce || 3;
        this.type = "jumppad";
        this.collGroup = "level";
        this.fillColor = color.jumpBg;
        this.strokeColor = color.jumpOl;
    }
}

class Key extends Obj {
    constructor(obj) {
        obj.origin = new Vec(0.5, 0.5);
        obj.size = new Vec(20,20);
        super(obj);
        this.unlocking = obj.unlocking || 'allLocks';
        this.type = "key";
        this.collGroup = "keys";
        let defs = [
            ['#ffff88', null, -5,0, -8,3, -8,6, -11,6, -11,3, -14,-1, -14,-3, -11,-5, -8,-5, -5,-3, 8,-3, 8,-2, 7,-2, 7,1, 5,1, 5,-1, -5,-1, 'c'],
            [null, '#000000', -13,-2, -11,-2, -11,1],
            [null, '#000000', -6,-2, -8,-2, -8,1],
        ];
        this.currentPath = createPath(defs);
    }
    render(ctx) {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        renderPaths(ctx, this.currentPath);
        ctx.restore();
    }
}
class Hourglass extends Obj {
    constructor(obj) {
        obj.origin = new Vec(0.5, 0.5);
        obj.size = new Vec(20,20);
        super(obj);
        this.type = "hourglass";
        this.collGroup = "collect";
        this.fillColor = '#ffffdd';
        this.textFillColor = '#ffffdd';
        this.strokeColor = '#ffff00';
        this.startTime = obj.startTime || Infinity;
        this.time = this.startTime;
        let defs = [
            [color.cloakBg,color.cloakOl, -5,-10, 0,0, -5,10, 5,10, 0,0, 5,-10, 'c'],
            [color.bone, null, -3,-5, 0,0, 3,-5, 'c'],
            [color.bone, null, -4,9, 0,7, 4,9, 'c'],
            [null, '#aa8822', -7,-10, 7,-10],
            [null, '#aa8822', -7,10, 7,10],
            [null, '#aa8822', -5,-9, -5,9],
            [null, '#aa8822', 5,-9, 5,9],
        ];
        this.currentPath = createPath(defs);
    }
    update(delta) {
        if(this.time < -0.9) {
            this.game.player.stopUpdates = true;
            this.game.addObj(new LevelBlender({
                target:this,
                game:game,
                radius:game.canvas.width,
                rate:game.canvas.width/2,
                finishedCallback:(blendObj)=>{
                    game.removeObj(blendObj);
                    this.game.loadCurrentLevel();
                }
            }));
        } else {
            this.time -= delta;
        }
    }
    render(ctx) {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        renderPaths(ctx, this.currentPath);
        if(this.time < Infinity) {
            ctx.textAlign = "center";
            if(this.time <= 0) {
                ctx.font = "24px serif";
                ctx.fillStyle = 'red';
            } else {
                ctx.font = "12px serif";
                ctx.fillStyle = this.textFillColor;
            }
            ctx.fillText(Math.ceil(this.time), 0, -15);
        }
        ctx.restore();
    }
}
class Text extends Obj {
    constructor(obj) {
        super(obj);
        this.type = "text";
        this.collGroup = "text";
        this.textFillColor = '#ffffdd';
        this.text = obj.text || "";
        this.textsize = obj.textsize || "12";
        this.startTime = obj.startTime || Infinity;
        this.time = this.startTime;
    }
    update(delta) {
        this.time -= delta;
        if(this.time < -0.5) {
            this.game.removeObj(this);
        }
    }
    render(ctx) {
        this.renderStart(ctx);
        ctx.textAlign = "center";
        ctx.font = this.textsize + "px serif";
        ctx.fillStyle = this.textFillColor;
        ctx.fillText(this.text, 0, 0);
        ctx.restore();
    }
}
let createPath = (defs, flipX) => {
    let fX = flipX ? -1 : 1;
    return defs.map(d=> {
        let p = {
            fill:d[0],
            stroke:d[1],
            path: new Path2D()
        };
        p.path.moveTo(d[2] * fX, d[3]);
        for(let i = 4; i <= d.length -2; i+=2) {
            p.path.lineTo(d[i] * fX, d[i+1]);
        }
        if(d[d.length-1] == 'c') {
            p.path.closePath();
        }
        return p;
    });
}
let renderPaths = (ctx, paths) => {
    paths.forEach(p=> {
        if(p.fill) {
            ctx.fillStyle = p.fill;
            ctx.fill(p.path);
        }
        if(p.stroke) {
            ctx.strokeStyle = p.stroke;
            ctx.stroke(p.path); 
        }   
    });
}
class Player extends Obj {
    constructor(obj) {
        obj.size = new Vec(10,30);
        obj.origin = new Vec(0.5, 1);
        super(obj);
        this.respawnPos = this.pos.clone();
        this.type = "player";
        this.collGroup = "player";
        this.dPos = new Vec(0,0);
        this.speed = 100; // pixel per second
        this.dashFactor = 3;
        this.dashDuration = 0.25;
        this.dashtimer = this.dashDuration;
        this.jumpForce = 200;
        this.jumpReleased = true;
        this.gravity = 500;
        this.maxFallSpeed = 300;
        this.grounded = false;
        this.groundedTo = null;
        this.stopUpdates = false;
        this.stopRendering = false;
        this.walkDustTimout = 0.1;
        this.lastWalkDust = 0;
        let defs = [
            [color.cloakBg,color.cloakOl, -8,0, -3,-15, -2,-27, 5,-20, 5,0, 'c'],
            [color.bone, null, -2,-30, 0,-32, 3,-32, 6,-30, 6,-20, 2,-21, -2,-24],
            ['#000000', null, 3,-28, 5,-28, 5,-26, 3,-26],
            [null, '#aa8822', -3,-2, 12,-35],
            [null, '#ccccdd', 11,-34, 16,-31, 19,-27],
            [color.bone, null, -1,-7, -1,-9, 1,-9, 1,-7],
        ];
        this.paths = {
            r: createPath(defs),
            l: createPath(defs, true)
        };
        defs.push([null, color.bone, -8,-7, -20,-7]);
        defs.push([null, color.bone, -8,-14, -25,-14]);
        defs.push([null, color.bone, -6,-20, -22,-20]);
        this.paths.dr = createPath(defs);
        this.paths.dl = createPath(defs, true);
        
        this.currentPath = this.paths.r;
    }
    update(delta) {
        if(this.stopUpdates) {
            return;
        }
        let walking = this.grounded;
        if(game.actions.l) {
            this.dPos.x = -this.speed;
            this.currentPath = this.paths.l;
        } else if(game.actions.r) {
            this.dPos.x = this.speed;
            this.currentPath = this.paths.r;
        } else {
            this.dPos.x *= 0.2;
            walking = false;
            this.lastWalkDust = 0;
        }
        if(walking) {
            this.lastWalkDust -= delta;
            if(this.lastWalkDust < 0) {
                this.createWalkDust();
                this.lastWalkDust = this.walkDustTimout;
            }
        }
 
        if(this.grounded) { 
            if(this.groundedTo && this.groundedTo.type == "jumppad") {
                this.dPos.y = -this.jumpForce * (this.groundedTo.jumpforce);
            } else if(game.actions.j && this.jumpReleased) {
                this.jumpReleased = false;
                this.dPos.y = -this.jumpForce;
                this.dashtimer = this.dashDuration;
                this.createJumpDust();
            } else {
                this.dPos.y = 0;
            }
        } else {
            if(game.actions.j && this.dPos.y <0) {
                this.dPos.y += this.gravity * 0.5 * delta;
            } else {
                this.dPos.y += this.gravity * delta;
            }
            if(game.actions.d && this.dashtimer > 0) {
                this.dashtimer -= delta;
                if(game.actions.l) {
                    this.dPos.x = -this.speed * this.dashFactor;
                    this.currentPath = this.paths.dl;
                }
                if(game.actions.r) {
                    this.dPos.x = this.speed * this.dashFactor;
                    this.currentPath = this.paths.dr;
                }
            }
        }
        if(this.dPos.y > this.maxFallSpeed) {
            this.dPos.y = this.maxFallSpeed;
        }

        this.pos = this.pos.plus(this.dPos.multi(delta));

        // Collisions
        this.grounded = false;
        let br = this.pos.clone().add(6,0);
        let bl = this.pos.clone().add(-6,0);
        let tl = bl.clone().add(0,-29);
        let tr = br.clone().add(0,-29);
        let t = this.pos.clone().add(0,-29);
        let r = this.pos.clone().add(7,-15);
        let l = this.pos.clone().add(-7,-15);

        let deadlyContact = false;
        game.getColliderObjs("level").forEach(o=> {
            let deadlyObject = ['spikes'].indexOf(o.type) >= 0;
            let otl = o.pos.clone().add(
                -o.size.x * o.origin.x,
                -o.size.y * o.origin.y,
            );
            let obr = o.pos.clone().add(
                o.size.x * (1 - o.origin.x),
                o.size.y * (1 - o.origin.y),
            );
            // jump - head
            if(this.dPos.y < 0 && t.y >= otl.y && t.y <= obr.y && t.x >= otl.x && t.x <= obr.x) {
                this.dPos.y = 0;
                this.pos.y = obr.y + 28;
                deadlyContact |= deadlyObject;
            }

            // right
            if(this.dPos.x > 0 && r.y >= otl.y && r.y <= obr.y && r.x >= otl.x && r.x <= obr.x) {
                this.dPos.x = 0;
                this.pos.x = otl.x -8;
                br = this.pos.clone().add(6,0);
                bl = this.pos.clone().add(-6,0);
                deadlyContact |= deadlyObject;
            }

            // left
            if(this.dPos.x < 0 && l.y >= otl.y && l.y <= obr.y && l.x >= otl.x && l.x <= obr.x) {
                this.dPos.x = 0;
                this.pos.x = obr.x +8;
                br = this.pos.clone().add(6,0);
                bl = this.pos.clone().add(-6,0);
                deadlyContact |= deadlyObject;
            }

            // bottom
            if(
                (br.y >= otl.y && br.y <= obr.y && br.x >= otl.x && br.x <= obr.x)
                || (bl.y >= otl.y && bl.y <= obr.y && bl.x >= otl.x && bl.x <= obr.x)
            ) {
                this.grounded = true;
                if(!this.groundedTo || this.groundedTo.type != "jumppad")
                this.groundedTo = o;
                this.pos.y = otl.y;
                deadlyContact |= deadlyObject;
            }
            
        });
        if(!this.grounded) {
            this.groundedTo = null;
        }
        game.getColliderObjs("collect").forEach(o=> {
            if (
                tl.x < o.pos.x + o.size.x * (1-o.origin.x) &&
                tr.x > o.pos.x - o.size.x * (1-o.origin.x) &&
                tl.y < o.pos.y + o.size.y * o.origin.y &&
                bl.y > o.pos.y - o.size.y * o.origin.y
            ) {
                this.game.removeObj(o);
            }
        });
        game.getColliderObjs("keys").forEach(o=> {
            if (
                tl.x < o.pos.x + o.size.x * (1-o.origin.x) &&
                tr.x > o.pos.x - o.size.x * (1-o.origin.x) &&
                tl.y < o.pos.y + o.size.y * o.origin.y &&
                bl.y > o.pos.y - o.size.y * o.origin.y
            ) {
                game.getColliderObjs("level").forEach(d=> {
                    if(d.lock == o.unlocking) {
                        d.unlocked = true;
                    }
                })
                console.log(o.unlocking);
                this.game.removeObj(o);
            }
        });
        if(game.getColliderObjs("collect").length == 0) {
            game.finishedCurrentLevel();
        }
        
        if(this.pos.y > this.game.canvas.height || deadlyContact) {
            this.dPos.x = 0;
            this.dPos.y = 0;
            this.createDeathDust(10);
            this.stopUpdates = true;
            this.stopRendering = true;
            let player = this;
            setTimeout(()=> player.respawn(), 1000);
        }
    }
    respawn() {
        this.stopUpdates = false;
        this.stopRendering = false;
        this.pos = this.respawnPos.clone();
        this.createDeathDust(15);
    }
    createDeathDust(amount) {
        for(let i = 0; i < (amount || 10); i++) {
            let dustPos = new Vec(this.pos.x + Math.random() * 20 - 10, this.pos.y - 14 + Math.random() * 30 - 15);
            this.game.addObj(new Dust({
                pos:dustPos, 
                size:Math.random() * 8 + 5, 
                ttl:Math.random() * 0.8 + 0.5
            }))
        }
    }
    createWalkDust() {
        this.game.addObj(new Dust({
            pos:this.pos.clone(), 
            size:2, 
            ttl:Math.random() * 0.4 + 0.2,
            dx:80, dy:40,
            dyd:40
        }));
    }
    createJumpDust() {
        for(let i = 0; i < 5; i++) {
            this.game.addObj(new Dust({
                pos:this.pos.clone(), 
                size:4, 
                ttl:Math.random() * 0.4 + 0.2,
                dx:80, dy:20,
                dxd:40, dyd:20
            }));
        }
    }
    render(ctx) {
        if(this.stopRendering) {
            return;
        }
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        renderPaths(ctx, this.currentPath);
        ctx.restore();
    }
}

const levelData = `
p~197~380ยงt~173~304~Use WASD to move~0~12ยงt~643~322~Collect these hourglasses~0~12ยงt~406~134~DEATH'S APPRENTICE~0~66ยงt~404~166~Welcome to the first day of your apprenticeship in Deaths's realm.~0~24ยงt~203~321~(or arrow keys)~0~12ยงh~621~422~0ยงt~581~537~By the way: Use the [M] key to toggle the music on and off... ~0~12ยงf~127~348~33~103ยงf~661~347~31~104ยงf~125~333~567~15ยงf~126~450~567~51ยงt~403~235~Your tasks are simple: collect the hourglasses for your master.~0~18ยงt~727~49~starts with your first move~0~12ยงt~626~23~Speedrun Clock:~0~18
#
p~236~194ยงf~717~219~84~281ยงf~505~389~212~111ยงf~182~494~80~6ยงf~196~487~80~7ยงf~209~481~78~6ยงf~222~475~77~6ยงf~235~469~78~6ยงf~246~463~78~6ยงf~318~429~187~81ยงt~231~374~Stairs can be walked~0~12ยงf~445~351~60~78ยงh~679~359~0ยงt~127~152~Press Up (or W) to jump~0~12ยงt~460~258~Hold Up (or W) to jump higher~0~12ยงh~475~330~0ยงh~350~404~0ยงh~98~468~0ยงf~-36~135~66~366ยงf~2~115~307~21ยงf~288~136~21~105ยงf~103~240~204~16ยงf~103~209~41~33ยงf~258~457~54~6ยงf~269~452~42~5ยงf~283~446~28~6ยงf~309~434~10~7ยงf~295~440~25~7ยงf~1~500~397~30
#
h~738~364~0ยงp~76~463ยงf~407~498~71~30ยงf~519~454~61~18ยงf~614~421~60~22ยงf~710~391~60~23ยงf~-1~335~53~264ยงf~251~522~30~81ยงf~434~520~20~82ยงf~541~467~20~137ยงf~635~437~22~168ยงf~731~407~23~198ยงf~49~503~279~34ยงt~390~194~So? Too easy, you say? Ok, here are more hourglasses for you to collect...~0~24ยงt~584~224~Dont fall down! Or....~0~18ยงt~639~248~You'll respawn ;-)~0~12
#
f~42~93~97~36ยงf~227~1~24~468ยงf~67~562~98~37ยงf~226~560~23~26ยงf~339~557~100~33ยงf~502~494~100~25ยงf~345~419~87~28ยงf~506~350~75~33ยงf~387~292~41~33ยงf~511~236~52~28ยงf~389~165~42~29ยงf~511~109~104~24ยงf~646~95~27~530ยงf~552~105~95~5ยงf~573~100~75~5ยงf~599~95~50~5ยงf~620~89~86~7ยงf~723~552~28~64ยงf~705~543~63~9ยงp~92~33ยงh~734~510~0ยงh~295~502~0ยงh~522~89~0ยงt~409~29~Some more todos, young apprentice...~0~18ยงt~354~48~Go, get 'em all! Quick!~0~12
#
f~687~271~33~115ยงf~93~271~32~114ยงf~92~383~628~29ยงf~92~264~628~7ยงp~154~301ยงh~640~354~15ยงt~253~207~I recently mentioned the word "quick"...~0~18ยงt~373~225~...some hourglasses have only a few seconds left...~0~14ยงt~512~240~... so you got to hurry up!~0~12ยงt~551~440~As soon as one hourglass reaches zero, your lesson will restart.~0~12ยงt~621~462~An apprenticeship is no piece of cake, after all.~0~12
#
f~289~298~210~131ยงf~321~494~145~60ยงf~465~536~211~18ยงf~102~537~219~17ยงf~675~104~19~450ยงf~84~99~610~5ยงf~82~100~21~456ยงf~578~246~47~23ยงf~103~305~42~20ยงf~120~354~61~20ยงf~198~467~47~19ยงf~150~410~64~20ยงf~184~257~47~20ยงf~637~307~39~20ยงf~605~366~45~20ยงf~570~425~42~23ยงf~537~475~40~17ยงp~388~256ยงh~602~219~22ยงh~198~228~17ยงh~129~506~32ยงh~639~504~6ยงt~384~57~It's time for a little test, my apprentice!~0~18ยงt~385~80~You'll have to choose the order in which you should collect the hourglasses.~0~12
#
f~166~329~28~275ยงf~488~329~30~270ยงf~90~310~167~19ยงf~437~308~168~21ยงp~115~281ยงh~586~286~0ยงt~204~77~Sometimes, when it looks too far...~0~18ยงt~462~90~... a little well timed SHIFT helps.~0~18ยงt~232~152~Jump while walking, aaaand...~0~12ยงt~417~166~.. press [SHIFT] for a little extra push.~0~12ยงf~76~229~14~99
#
h~595~398~0ยงf~123~429~585~20ยงp~284~392ยงj~389~424~44~5~1.7ยงj~677~424~30~5~2ยงf~538~301~117~14ยงh~178~399~0ยงt~261~83~An obstacle is to big for you to jump over it? ~0~18ยงt~377~116~When you are lucky, Death left a handy jumppad for you nearby.~0~14ยงt~467~145~Just walk onto it, and let the thing do its magic... weeee!eh!~0~12ยงt~310~473~Always remember: when you are stuck, just jump off a cliff. You'll respawn. ;-)~0~12ยงf~443~300~36~129ยงf~233~298~41~131
#
d~411~267~5~97~d1ยงk~471~535~d1ยงf~71~434~210~15ยงf~222~427~59~8ยงf~243~420~60~8ยงf~261~413~57~8ยงf~279~408~54~7ยงf~294~400~56~9ยงf~313~395~60~9ยงf~325~387~65~10ยงf~345~379~63~10ยงf~363~372~67~9ยงf~387~362~347~10ยงf~382~131~42~134ยงf~377~258~370~11ยงf~289~122~146~13ยงf~725~253~29~120ยงh~690~336~0ยงf~7~564~522~15ยงj~15~559~32~5~2ยงt~164~77~When your path is locked...~0~20ยงt~462~461~... the indirect way may turns out to be the "KEY" to success.~0~14ยงp~329~287
#
f~13~18~765~18ยงf~752~34~26~547ยงf~228~202~22~172ยงf~246~359~190~15ยงf~416~217~20~157ยงf~523~421~114~17ยงf~481~375~28~15ยงf~568~259~25~13ยงf~608~201~148~17ยงj~680~569~43~5~1.8ยงf~13~35~27~541ยงf~40~208~143~18ยงf~162~226~18~274ยงj~40~569~101~5~2.2ยงf~226~182~124~21ยงf~334~35~20~147ยงf~107~112~172~18ยงf~179~34~18~80ยงp~148~76ยงk~230~78~1ยงd~571~472~5~102~1ยงf~564~438~21~34ยงf~242~372~17~70ยงd~373~373~5~71~2ยงf~244~440~211~17ยงk~284~265~3ยงf~327~203~21~92ยงj~257~356~152~5~2ยงh~301~408~0ยงf~510~35~23~101ยงf~533~117~144~19ยงd~661~36~5~81~3ยงh~563~79~0ยงk~638~241~2ยงf~624~314~128~18ยงh~96~373~0ยงf~14~573~300~20ยงf~404~573~374~20ยงt~83~53~Jump around~0~14ยงf~538~318~86~14
#
s~224~453~124~45~1ยงs~410~454~262~81~1ยงf~212~495~153~30ยงf~403~528~279~20ยงf~348~449~62~101ยงf~673~450~91~104ยงf~38~447~185~86ยงf~466~390~36~16ยงf~555~357~38~19ยงh~733~426~0ยงp~64~412ยงt~234~119~Spikes in Death's domain ?!?!??~0~20ยงt~325~157~Well, yes. Why not?~0~16ยงt~394~187~Dont touch them.~0~12
#
s~155~552~244~49~1ยงs~160~381~250~45~0ยงf~29~548~127~53ยงf~510~394~54~55ยงf~152~361~263~30ยงf~397~548~94~56ยงf~248~519~59~17ยงj~445~543~37~5~2ยงs~431~176~45~21~1ยงs~521~176~38~19~1ยงs~605~173~38~22~1ยงh~726~165~0ยงd~364~92~5~104~allLocksยงk~588~343~allLocksยงj~200~357~31~5~1.7ยงp~55~517ยงs~289~209~410~60~0ยงf~283~193~482~26ยงf~34~15~342~83ยงt~186~50~Roses are red, Violets are blue.~0~18ยงt~221~70~A spike on the head, will also hurt you.~0~15
#
s~-11~566~822~37~1ยงf~286~469~215~23ยงj~472~464~28~5~1.7ยงj~286~464~29~5~1.7ยงf~628~412~32~22ยงf~128~412~28~17ยงj~629~407~29~5~1.7ยงj~127~407~30~5~1.7ยงf~356~207~55~43ยงf~331~159~112~50ยงf~329~111~18~53ยงf~382~116~13~46ยงf~431~110~12~49ยงf~339~95~97~21ยงf~361~135~10~11ยงf~409~139~11~8ยงt~386~53~That's the end, my apprentice!~0~32ยงt~387~74~The deadline of js13k 2022 is here, and the game-dev is too tired to add more levels ;-)~0~12ยงt~384~295~You took {speedRunTime} to complete your training~0~18ยงt~385~325~(Your best time ever was {bestTime})~0~12ยงt~390~514~THX for playing! Hope you had fun~0~12ยงp~386~357ยงt~385~340~Press F5, if you want to try again...~0~12
`;
const game = new Game(document.getElementById('canvas'), levelData.trim());
game.run();
game.loadNextLevel();


